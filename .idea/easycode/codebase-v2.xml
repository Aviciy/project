<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/Abstract/connector.py;C:/Users/ellen/RiderProjects/Synalytix/project/Abstract/logger.py;C:/Users/ellen/RiderProjects/Synalytix/project/Abstract/websocket_handler.py;C:/Users/ellen/RiderProjects/Synalytix/project/Loggers/composite_logger.py;C:/Users/ellen/RiderProjects/Synalytix/project/Loggers/console_logger.py;C:/Users/ellen/RiderProjects/Synalytix/project/Loggers/file_logger.py;C:/Users/ellen/RiderProjects/Synalytix/project/MEXC/__init__.py;C:/Users/ellen/RiderProjects/Synalytix/project/MEXC/MEXC_connector.py;C:/Users/ellen/RiderProjects/Synalytix/project/MEXC/MEXC_endpoints.py;C:/Users/ellen/RiderProjects/Synalytix/project/MEXC_settings.json;C:/Users/ellen/RiderProjects/Synalytix/project/models.py;C:/Users/ellen/RiderProjects/Synalytix/project/test.py" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;C:/Users/ellen/RiderProjects/Synalytix/project&quot;:&quot;{\&quot;/MEXC/MEXC_endpoints.py\&quot;:\&quot;This file defines the API endpoints for interacting with the MEXC exchange via their API.\\n\\nKey functions:\\n\\n- MEXCEndpoints - The main StrEnum class that defines all the endpoint URLs as string enum values.\\n\\n- BASE - The base URL for the API. \\n\\n- WEBSOCKET_BASE - The base URL for the websocket API.\\n\\n- Public endpoints - Endpoints for getting public market data like ticker, order book, balances etc.\\n\\n- Private endpoints - Endpoints requiring authentication for account, order, trade data. \\n\\n- Margin endpoints - Additional endpoints for interacting with the margin/lending part of the exchange.\\n\\nThe main purpose of the file is to centralize all the MEXC API endpoints in one place. This allows any code interfacing with the MEXC API to import these endpoints as string values rather than having the URLs hardcoded throughout the code. It provides a clean interface to interact with the different parts of the MEXC API.\&quot;,\&quot;/MEXC_settings.json\&quot;:\&quot;This JSON file contains settings for connecting to and interacting with the MEXC cryptocurrency exchange via their API.\\n\\nKey functions:\\n\\n- key - The API key issued by MEXC for authentication.\\n\\n- secret - The secret key issued by MEXC to generate signatures for authenticated requests. \\n\\n- url - The base URL for the MEXC REST API.\\n\\n- wss - The URL for the MEXC WebSocket API for real-time market data. \\n\\n- type_of_full_subscription - Specifies the type of market data to subscribe to via WebSocket (order book level 2 in this case).\\n\\n- warning_delay_sec - Threshold for logging a warning if market data updates are delayed. \\n\\n- maximum_delay_sec - Threshold for terminating the WebSocket connection if market data delays exceed this.\\n\\nThis file centralizes the authentication credentials and configuration needed to connect an application or script to the MEXC exchange APIs. It allows easy access to market data and trading functionality via the REST and WebSocket APIs. The delay thresholds help monitor the quality of real-time data from the exchange.\&quot;,\&quot;/Loggers/composite_logger.py\&quot;:\&quot;This file defines a CompositeLogger class that implements the Logger interface from the Abstract.logger module.\\n\\nA composite logger is used to log messages to multiple underlying logger objects. It takes in one or more logger objects in its constructor and stores them in a private __loggers attribute.\\n\\nThe key functions are:\\n\\n- __init__ - Constructor that initializes the private __loggers attribute to store the passed in logger objects.\\n\\n- trace, debug, info, warning, error, critical - These methods implement the logging levels defined in the Logger interface. They simply call the corresponding method on each logger object stored in __loggers to forward the log message.\\n\\nSo in summary, this CompositeLogger class allows logging to multiple loggers simultaneously by forwarding log messages to each underlying logger object. This provides a way to compose multiple loggers together to log to different outputs/formats.\&quot;,\&quot;/Abstract/logger.py\&quot;:\&quot;This file defines an abstract base class called Logger that acts as an interface for logging classes.\\n\\nKey points:\\n\\n- It uses ABCMeta and abstractmethod from the abc module to define an abstract base class. This means any concrete subclasses must implement the abstract methods.\\n\\n- It defines 6 logging methods - trace, debug, info, warning, error, critical - corresponding to different logging levels. \\n\\n- Each method is decorated with @abstractmethod, so any concrete subclass must provide an implementation of each method.\\n\\n- The methods all take a message string as a parameter and don\\u0027t return anything (return type None).\\n\\n- Concrete subclasses can then implement these abstract methods to perform actual logging, e.g. writing to a file, console, database etc. \\n\\n- This allows different logging backends to be implemented while providing a common interface via the Logger class.\\n\\nKey functions:\\n\\n- trace, debug, info, warning, error, critical - The abstract logging methods that must be implemented by subclasses. These define the common logging API.\\n\\nSo in summary, it defines an abstract base class that concrete logging classes can inherit from, providing a common interface for logging messages at different levels.\&quot;,\&quot;/Abstract/websocket_handler.py\&quot;:\&quot;This file defines an abstract base class for WebSocket handlers in Python.\\n\\nThe key things it does:\\n\\n- Defines an abstract base class WebSocketHandler using ABCMeta\\n- Initializes the class with no parameters \\n- Defines 4 abstract methods that must be implemented by subclasses:\\n  - on_message - Called when a message is received\\n  - on_error - Called when an error occurs\\n  - on_close - Called when the connection closes\\n  - on_open - Called when the connection opens\\n- These methods raise a NotImplementedError to indicate they must be implemented by subclasses\\n\\nSo in summary, it provides a common interface for classes that want to handle WebSocket events like receiving messages, errors, open/close events. Subclasses must implement these abstract methods to define the actual handling logic. This allows different handler classes to be used interchangeably as long as they implement this common interface.\\n\\nThe key functions defined are:\\n\\n- on_message\\n- on_error \\n- on_close\\n- on_open\\n\\nThese define the callback interface for WebSocket event handling.\&quot;,\&quot;/Abstract/connector.py\&quot;:\&quot;This file defines an abstract base class called Connector that acts as an interface for cryptocurrency exchange connectors.\\n\\nThe key things it does:\\n\\n- Defines the Connector class as an abstract base class using ABCMeta metaclass. This means subclasses must implement all abstract methods.\\n\\n- Defines several abstract methods that subclasses must implement, related to connecting to and interacting with an exchange:\\n\\n  - start() and stop() to connect/disconnect\\n  - get_name() to get exchange name\\n  - check_connection() to check connection status\\n  - get_server_time() to get server time\\n  - get_exchange_info() to get supported symbols\\n  - get_ticker(), get_book() to get market data\\n  - get_balances() to get account balances\\n  - subscribe(), unsubscribe() to subscribe to market data\\n\\n- The purpose is to define a common interface that specific exchange connector classes (e.g. BinanceConnector, CoinbaseConnector) can inherit and implement to provide a standardized way of connecting to and interacting with different exchanges.\\n\\nSo in summary, it defines an abstract base class and interface for cryptocurrency exchange connectors to implement common connector functionality in a standardized way.\&quot;,\&quot;/MEXC/__init__.py\&quot;:\&quot;This __init__.py file is initializing the MEXC Python package. Some key things it is doing:\\n\\n- Importing the MEXCEndpoints class from the MEXC_endpoints.py file. This class likely defines the different API endpoints that can be called.\\n\\n- Importing the MEXCConnector class from the MEXC_connector.py file. This class is likely responsible for connecting to the MEXC API and making requests. \\n\\n- By importing these classes and not modifying them, it makes them available at the top level of the MEXC package.\\n\\nSo in summary:\\n\\n- Makes the endpoint definitions and connector classes available at the top level of the MEXC package.\\n\\n- MEXCEndpoints - Defines the different API endpoints that can be called.\\n\\n- MEXCConnector - Handles connecting to the API and making requests.\\n\\nThe key functions would be:\\n\\n- Any functions defined in MEXCEndpoints for calling specific API endpoints.\\n\\n- Any functions in MEXCConnector for initializing a connection, making requests, and handling responses.\\n\\nSo this file is just initializing the package and exposing the key classes for interacting with the MEXC API from other files within the MEXC package.\&quot;,\&quot;/test.py\&quot;:\&quot;This Python file is testing the functionality of a cryptocurrency exchange connector using the MEXC exchange as an example.\\n\\nKey things it does:\\n\\n- Sets up logging using a CompositeLogger that logs to both console and file\\n- Loads settings for connecting to MEXC from a JSON file\\n- Creates an MEXC connector using the LoggingWebSocketHandler and settings\\n- Tests basic connector functions:\\n  - start() \\n  - get_name()\\n  - check_connection()\\n  - get_server_time()\\n  - get_exchange_info()\\n  - get_ticker() \\n  - get_book()\\n  - get_balances()\\n- Subscribes to some market data streams\\n- Stops the connector\\n\\nKey functions tested:\\n\\n- start() - Starts the connector\\n- get_name() - Gets the exchange name \\n- check_connection() - Checks connection status\\n- get_server_time() - Gets server time from exchange  \\n- get_exchange_info() - Gets general exchange info\\n- get_ticker() - Gets ticker data for a market\\n- get_book() - Gets order book for a market\\n- get_balances() - Gets account balances  \\n- subscribe() - Subscribes to a market data stream\\n- stop() - Stops the connector\\n\\nSo in summary, it is testing the basic functionality of connecting to and retrieving data from a cryptocurrency exchange using the MEXC connector library.\&quot;,\&quot;/MEXC/MEXC_connector.py\&quot;:\&quot;This file defines a class called MEXCConnector that acts as a connector/client for the MEXC exchange API.\\n\\nKey functions:\\n\\n- start() - Starts the websocket connection and thread.\\n- stop() - Stops the websocket connection and thread.  \\n- get_name() - Returns the name of the exchange (\\\&quot;MEXC\\\&quot;).\\n- check_connection() - Checks if the API connection is alive.\\n- get_server_time() - Gets the server time from the API.\\n- get_ticker() - Gets ticker data for a symbol.\\n- get_exchange_info() - Gets all symbols available on the exchange. \\n- get_book() - Gets order book data for a symbol.\\n- get_balances() - Gets account balance data.\\n- subscribe() - Subscribes to websocket market data for a symbol.\\n- unsubscribe() - Unsubscribes from websocket market data.\\n- on_message() - Callback for websocket messages.\\n- on_error() - Callback for websocket errors.\\n- on_close() - Callback for websocket close.\\n- on_open() - Callback when websocket connects.\\n- __make_signed_request() - Helper to make signed API requests.\\n\\nSo in summary, it provides functions to interact with the MEXC REST and websocket APIs, including getting market data, account info, and subscribing to market updates.\&quot;,\&quot;/Loggers/console_logger.py\&quot;:\&quot;This file defines a ConsoleLogger class that implements the Logger abstract base class.\\n\\nThe ConsoleLogger class logs messages to the console/terminal rather than to a file.\\n\\nKey functions:\\n\\n- trace(), debug(), info(), warning(), error(), critical(): These methods log messages at different severity levels to the console, prefixing each message with the current datetime, log level name, and message text.\\n\\n- They implement the abstract methods defined in the Logger base class to provide a concrete logging implementation.\\n\\n- The logger formats the output in a consistent way for each log level, making the logged messages easy to read and understand at a glance. \\n\\n- By inheriting from Logger, ConsoleLogger can be used interchangeably with any other logger that implements the Logger interface, following the Strategy pattern.\\n\\nSo in summary, this class provides a console/terminal-based logging implementation that is compatible with any code expecting a Logger interface, formatting log messages clearly for human readability.\&quot;,\&quot;/Loggers/file_logger.py\&quot;:\&quot;This file defines a FileLogger class that implements logging to a file.\\n\\nKey points:\\n\\n- It inherits from the abstract Logger class defined in Abstract/logger.py, which defines the logging level methods (trace, debug, info, etc).\\n\\n- The constructor takes a filename parameter to specify the log file. \\n\\n- It has a private __log() method that handles writing the actual log entry to the file, including timestamp and message formatting.\\n\\n- Each of the logging level methods (trace, debug, etc) simply call the private __log() method, passing the appropriately formatted message.\\n\\n- Logging is done by appending to the file, rather than overwriting it each time.\\n\\nKey functions:\\n\\n- __init__() - Constructor that initializes the filename \\n- __log() - Private method that writes the log entry to the file\\n- trace(), debug(), info(), etc - Implement the abstract logging level methods by calling __log()\\n\\nSo in summary, it provides file-based logging by implementing the abstract logger interface and writing log entries to a file in a consistent format.\&quot;,\&quot;/models.py\&quot;:\&quot;This file defines several classes that are used to model different entities and concepts related to a brokerage system:\\n\\n- BrokerEvent - Defines different event types that can occur in the brokerage system like login/logout, errors, subscription events etc. Used to categorize events.\\n\\n- SubscriptionModel - Defines different market data subscription types like top of book, full book, trades etc. \\n\\n- OrderType - Defines different order types like market, limit etc. \\n\\n- OrderStatus - Defines possible order statuses like partially filled, filled, new, canceled etc.\\n\\n- TimeInForce - Defines time-in-force instructions for orders like day, good till cancel, immediate or cancel, fill or kill etc.\\n\\nKey functions:\\n\\n- Define common event types, subscription models, order attributes etc using Python classes. This provides a common vocabulary/taxonomy.\\n\\n- Act as data models that can be used by other parts of the system to represent real world entities like events, orders, subscriptions etc. \\n\\n- Provide a common reference for different parts of the system to interpret entity types, statuses etc in a standardized way.\\n\\nSo in summary, it defines common domain models/entities for the brokerage system to provide a standardized way to represent and interpret different concepts throughout the codebase.\&quot;}&quot;}" />
  </component>
</project>